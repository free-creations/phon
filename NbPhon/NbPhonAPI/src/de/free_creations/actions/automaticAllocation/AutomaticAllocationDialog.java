/*
 * Copyright 2014 Harald Postner<harald at free-creations.de>.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package de.free_creations.actions.automaticAllocation;

import de.free_creations.actions.automaticAllocation.AutomaticAllocationExecutor.ProgressIndicator;
import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.util.List;
import java.util.concurrent.CancellationException;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import javax.swing.AbstractAction;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JComponent;
import javax.swing.KeyStroke;
import javax.swing.SwingWorker;
import org.openide.util.Exceptions;

/**
 *
 * @author Harald Postner<harald at free-creations.de>
 */
public class AutomaticAllocationDialog extends javax.swing.JDialog {

  private static final String txtStop = "Stop";
  private static final String txtClose = "Close";

  private class Allocator extends SwingWorker<Void, ProgressIndicator> {

    private final boolean fullReAllocation;
    private boolean halted;
    private String endMessage = "";

    public Allocator(boolean fullReAllocation) {
      this.fullReAllocation = fullReAllocation;
      halted = false;
    }

    @Override
    protected Void doInBackground() throws Exception {
      AutomaticAllocationExecutor exe = new AutomaticAllocationExecutor(fullReAllocation);
      boolean more = true;
      while (more && (!halted)) {
        publish(exe.getProgress());
        Thread.sleep(1); // unfortunate, but we must give the AWT thread some time to refresh
        more = exe.doNext();
      }
      endMessage = exe.getProcessQuality();
      return null;
    }

    public void halt() {
      halted = true;
    }

    @Override
    protected void process(List<ProgressIndicator> chunks) {
      ProgressIndicator last = chunks.get(chunks.size() - 1);
      progressBar.setValue(last.percentFinished);
      lblMessage.setText(last.message);
    }

    @Override
    protected void done() {
      try {
        get(0, TimeUnit.MICROSECONDS); // to make sure the thread has finished

        btnImprove.setEnabled(true);
        btnAllocationFromScratch.setEnabled(true);
        lblProcessQuality.setForeground(Color.black);
        lblProcessQuality.setText(endMessage);
        stopCloseButton.setText(txtClose);
        action = null;

      } catch (ExecutionException ex) {
        // The Automatic Allocation Executor had a problem.
        Throwable cause = ex.getCause();
        lblProcessQuality.setForeground(Color.red);
        lblProcessQuality.setText(cause.getMessage());
        btnImprove.setEnabled(false);
        btnAllocationFromScratch.setEnabled(false);
        stopCloseButton.setText(txtClose);
      } catch (CancellationException | InterruptedException | TimeoutException ex) {
        // This should never happen!!!
        Exceptions.printStackTrace(ex);
      }

    }
  }

  private Allocator action = null;

  /**
   * Creates new form NewOkCancelDialog
   */
  public AutomaticAllocationDialog(java.awt.Frame parent, boolean modal) {
    super(parent, modal);
    initComponents();

    if (parent != null) {
      setLocationRelativeTo(parent);
    }
    lblMessage.setText("");
    lblProcessQuality.setText("");
    stopCloseButton.setText(txtStop);
    // Close the dialog when Esc is pressed
    String cancelName = "cancel";
    InputMap inputMap = getRootPane().getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
    inputMap.put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0), cancelName);
    ActionMap actionMap = getRootPane().getActionMap();
    actionMap.put(cancelName, new AbstractAction() {
      @Override
      public void actionPerformed(ActionEvent e) {
        CancelAndClose(null);
      }
    });
  }

  /**
   * This method is called from within the constructor to initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is always
   * regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
  // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
  private void initComponents() {

    btnImprove = new javax.swing.JButton();
    btnAllocationFromScratch = new javax.swing.JButton();
    stopCloseButton = new javax.swing.JButton();
    progressBar = new javax.swing.JProgressBar();
    lblMessage = new javax.swing.JLabel();
    lblProcessQuality = new javax.swing.JLabel();

    setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
    addWindowListener(new java.awt.event.WindowAdapter() {
      public void windowClosing(java.awt.event.WindowEvent evt) {
        CancelAndClose(evt);
      }
    });

    org.openide.awt.Mnemonics.setLocalizedText(btnImprove, org.openide.util.NbBundle.getMessage(AutomaticAllocationDialog.class, "AutomaticAllocationDialog.btnImprove.text")); // NOI18N
    btnImprove.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        btnImproveActionPerformed(evt);
      }
    });

    org.openide.awt.Mnemonics.setLocalizedText(btnAllocationFromScratch, org.openide.util.NbBundle.getMessage(AutomaticAllocationDialog.class, "AutomaticAllocationDialog.btnAllocationFromScratch.text")); // NOI18N
    btnAllocationFromScratch.setDefaultCapable(false);
    btnAllocationFromScratch.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        btnAllocationFromScratchActionPerformed(evt);
      }
    });

    org.openide.awt.Mnemonics.setLocalizedText(stopCloseButton, org.openide.util.NbBundle.getMessage(AutomaticAllocationDialog.class, "AutomaticAllocationDialog.stopCloseButton.text")); // NOI18N
    stopCloseButton.addActionListener(new java.awt.event.ActionListener() {
      public void actionPerformed(java.awt.event.ActionEvent evt) {
        stopCloseButtonActionPerformed(evt);
      }
    });

    org.openide.awt.Mnemonics.setLocalizedText(lblMessage, org.openide.util.NbBundle.getMessage(AutomaticAllocationDialog.class, "AutomaticAllocationDialog.lblMessage.text")); // NOI18N

    lblProcessQuality.setForeground(java.awt.Color.red);
    org.openide.awt.Mnemonics.setLocalizedText(lblProcessQuality, org.openide.util.NbBundle.getMessage(AutomaticAllocationDialog.class, "AutomaticAllocationDialog.lblProcessQuality.text")); // NOI18N
    lblProcessQuality.setVerticalAlignment(javax.swing.SwingConstants.TOP);

    javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
    getContentPane().setLayout(layout);
    layout.setHorizontalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(layout.createSequentialGroup()
        .addContainerGap()
        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
          .addComponent(progressBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
          .addComponent(lblProcessQuality, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
          .addComponent(lblMessage, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
          .addGroup(layout.createSequentialGroup()
            .addGap(0, 67, Short.MAX_VALUE)
            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
              .addComponent(btnAllocationFromScratch, javax.swing.GroupLayout.PREFERRED_SIZE, 211, javax.swing.GroupLayout.PREFERRED_SIZE)
              .addComponent(btnImprove, javax.swing.GroupLayout.PREFERRED_SIZE, 211, javax.swing.GroupLayout.PREFERRED_SIZE)
              .addComponent(stopCloseButton, javax.swing.GroupLayout.PREFERRED_SIZE, 211, javax.swing.GroupLayout.PREFERRED_SIZE))
            .addGap(0, 68, Short.MAX_VALUE)))
        .addContainerGap())
    );
    layout.setVerticalGroup(
      layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
      .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
        .addGap(51, 51, 51)
        .addComponent(btnImprove)
        .addGap(38, 38, 38)
        .addComponent(btnAllocationFromScratch)
        .addGap(42, 42, 42)
        .addComponent(stopCloseButton)
        .addGap(18, 18, 18)
        .addComponent(lblMessage)
        .addGap(4, 4, 4)
        .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
        .addComponent(lblProcessQuality, javax.swing.GroupLayout.DEFAULT_SIZE, 49, Short.MAX_VALUE)
        .addGap(27, 27, 27))
    );

    getRootPane().setDefaultButton(btnAllocationFromScratch);

    pack();
  }// </editor-fold>//GEN-END:initComponents

    private void btnAllocationFromScratchActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAllocationFromScratchActionPerformed
      startAllocationAction(true);
    }//GEN-LAST:event_btnAllocationFromScratchActionPerformed

    private void stopCloseButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_stopCloseButtonActionPerformed

      if (action == null) {
        CancelAndClose(null);
      } else {
        stop();
      }
    }//GEN-LAST:event_stopCloseButtonActionPerformed

  private void startAllocationAction(boolean fullAllocation) {
    if (action == null) {
      progressBar.setValue(0);
      lblMessage.setText("");
      lblProcessQuality.setText("");
      btnImprove.setEnabled(false);
      btnAllocationFromScratch.setEnabled(false);
      stopCloseButton.setText(txtStop);
      action = new Allocator(fullAllocation);
      action.execute();
    }
  }

  /**
   * stop the running action
   */
  private void stop() {
    if (action != null) {
      action.halt();
      // wait until the last chunk has been done
      try {
        // wait at maximum for three seconds
        action.get(3000, TimeUnit.MILLISECONDS);
      } catch (CancellationException | InterruptedException | ExecutionException ex) {
        //Exceptions.printStackTrace(ex);
      } catch (TimeoutException ex) {
        // did not finish the last chunk within 3 seconds. Try to kill the process as the last resort.
        action.cancel(true);
        Exceptions.printStackTrace(ex);
      }
    }
    action = null;
  }

  /**
   * Closes the dialog and cancels further allocation work.
   */
    private void CancelAndClose(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_CancelAndClose
      stop();
      doClose();
    }//GEN-LAST:event_CancelAndClose

  private void btnImproveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnImproveActionPerformed
    startAllocationAction(false);
  }//GEN-LAST:event_btnImproveActionPerformed

  private void doClose() {
    setVisible(false);
    dispose();
  }

  /**
   * @param args the command line arguments
   */
  public static void main(String args[]) {
    /* Set the Nimbus look and feel */
    //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
     * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
     */
    try {
      for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
        if ("Nimbus".equals(info.getName())) {
          javax.swing.UIManager.setLookAndFeel(info.getClassName());
          break;
        }
      }
    } catch (ClassNotFoundException ex) {
      java.util.logging.Logger.getLogger(AutomaticAllocationDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (InstantiationException ex) {
      java.util.logging.Logger.getLogger(AutomaticAllocationDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (IllegalAccessException ex) {
      java.util.logging.Logger.getLogger(AutomaticAllocationDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    } catch (javax.swing.UnsupportedLookAndFeelException ex) {
      java.util.logging.Logger.getLogger(AutomaticAllocationDialog.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
    }
    //</editor-fold>

    /* Create and display the dialog */
    java.awt.EventQueue.invokeLater(new Runnable() {
      @Override
      public void run() {
        AutomaticAllocationDialog dialog = new AutomaticAllocationDialog(new javax.swing.JFrame(), true);
        dialog.addWindowListener(new java.awt.event.WindowAdapter() {
          @Override
          public void windowClosing(java.awt.event.WindowEvent e) {
            System.exit(0);
          }
        });
        dialog.setVisible(true);
      }
    });
  }

  // Variables declaration - do not modify//GEN-BEGIN:variables
  private javax.swing.JButton btnAllocationFromScratch;
  private javax.swing.JButton btnImprove;
  private javax.swing.JLabel lblMessage;
  private javax.swing.JLabel lblProcessQuality;
  private javax.swing.JProgressBar progressBar;
  private javax.swing.JButton stopCloseButton;
  // End of variables declaration//GEN-END:variables

}
